# Order Aggregate

<!-- how data is presisted in database -->

```json
{
  "id": "000000000-0000000-00000000000-0000000000",
  "customerId": "000000",
  "restaurantId": "000000",
  "deliveryAddress": "00000",
  "price": {
    "amount": 1000,
    "currency": "USD"
  },
  "items": ["0000", "0000"],
  "trackingId": "0000",
  "orderStatus": "deliverd",
  "failureMessages": ["message one", "message two"]
}
```

# Create order request

```json
{
  "restaurantId": "000000",
  "deliveryAddress": {
    "id": "0000",
    "street": "street",
    "postal_code": 216537,
    "city": "alexandria"
  },
  "items": ["0000", "0000"]
}
```

# Create order command

- logic manipulation
  - customer Id will fetched from the token
  - failure messages is initialized as empty list
  - order status has a "new" defalut value
  - tracking id will be generated by the application logic
  - price will be calculated from order items data
  - delivery address: if this id exists in addresses table, then just assign id to order aggregate, if not create new address and store it.

# Order response

```json
{
  "id": "000000000-0000000-00000000000-0000000000",
  "customerId": "000000",
  "restaurantId": "000000",
  "deliveryAddress": {
    "id": "0000",
    "street": "street",
    "postal_code": 216537,
    "city": "alexandria"
  },
  "price": {
    "amount": 1000,
    "currency": "USD"
  },
  "items": ["0000", "0000"],
  "trackingId": "0000",
  "orderStatus": "deliverd",
  "failureMessages": ["message one", "message two"]
}
```

# Create Order Command

```csharp
public record CreateOrderCommand(

);
```

- Notes
  - This is a the rich json response structure instead of providing raw IDs, use SQL join to achive this.
  - I can't reference items data here as it is a sub-entity in another aggreagte (restaurant aggreate), so IDs only are provided.

# SQL mapping

- orders (id, customer_id, restaurant_id, delivery_address, price, currency, tracking_id, order_status, failure_messages, items)
